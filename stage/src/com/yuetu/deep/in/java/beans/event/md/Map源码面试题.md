# Map源码面试题

## 说说HashMap的底层数据结构

答: HashMap都底层是数组+链表+红黑树的数据结构，数组主要是方便快速查找，时间复杂度O(1)，默认大小是16，数组下标索引是通过key的hashcode计算出来的。数组的元素叫做Node,当多个key的HashCode一致，但当key值不同时，单个Node就会转换成链表，链表的查询复杂度O(n) 当链表长度大于等于8并且数组大小超过64时，链表就会转化成红黑树，红黑树的复杂度O(log(n)) 简单的说，最坏的查询次数相当于红黑树的最大深度。

## HashMap、TreeMap、LinkedHashMap三者有啥相同点，有啥不同点？

答：相同点

1. ​	三者在特定的情况都是转化成红黑树；
2. 底层的Hash算法相同
3. 在迭代过程中，如果Map的数据被改动，都会报错

不同点:

1. HashMap的数据结构以数组为主，查询非常快。TreeMap数据结构以红黑树为主，利用红黑树的左小右大的特点，可以根据实现key的排序，LinkedHashMap基础上加上链表结构，实现了插入顺序和最少访问删除2中策略。
2. 由于Map底层数据结构的差别，导致了三者的使用场景的不同，TreeMap适合需要根据key排序的场景，LinkedMap适合插入顺序访问，或者需要删除最少使用元素场景。
3. 由于三种map底层数据结构有些差异导致上层API的封装不同

## 说一下Map的hash算法

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
//key在数组中的位置公式，tab[(n-1) & hash]
```

如上代码HashMap的hash算法

这个其实数学问题 计算出key的hashcode,因为key的不同类型计算出来的hashcode，接着计算出 h^(h>>16)这样算出来的hashcode比较分散

## 解决Hash冲突，大概有那些方法

1. hash算法
2. 自动扩容，当数组大小快满的时候，采取自动扩容，可以减少hash冲突
3. hash冲突时，采用链表来解决
4. hash冲突时，链表会自动转成红黑树。

## HashMap如何扩容的

扩容时机

1. put时，发现数组为空，进行初始化扩容，默认是16
2. put成功后，发现数组大小大于扩容阀门时，进行扩容，阀门大小是老数组的2倍

扩容的门阀是threshold每次扩容时，threshold都会重新计算的，门阀值等于数组大小*0.75

## hash冲突怎么处理

hash冲突是key值的hashcode计算相同，但key值不同的情况。

如果桶中元素原本只是一个链表，新增元素会追加到链表尾部
如果桶中的元素已经是链表，并且链表个数大于等于8

1. 如果此时数组大小小于64，数组再次扩容，链表不会转成红黑树
2. 如果此时数组大小大于64，链表直接转成红黑树

## 为什么链表大于等于8时，链表会转成红黑树

当链表太多时，遍历可能比较耗时，转成红黑树，可以遍历的复杂度降低，但是转成红黑树，有空间和转化耗时成本，通过泊松分布式计算，正常情况下，链表个数出现8的概率不足千分之一，正常情况下，链表不会转成红黑树，这是设计防止非正常情况，比如Hash算法出问题，导致整个链表轻易大于8，仍然能够快速遍历。

### 红黑树什么时候转成链表

当节点小于等于6时，红黑树会自动转成链表，主要还是考虑红黑树的空间成本，当节点小于等于6时，遍历链表也很快。

## HashMap在put时，如果数组已经有这个key，我不想把value覆盖怎么办，取值时，如果等到value是空时，想返回默认值？

1. 如果数组下已经存在key了，但是不想覆盖原value值，可以选择putlfAbsent方法，这个方法内置变量onlylfAbsent，内置true，就不会覆盖，我们常用的put方法内置onlylfAbsent是false，允许覆盖的。
2. 取值时，如果为空想返回默认值，可以使用getOrDefault方法，方法第一个参数为key,第二个参数为你想返回的默认值，如果map.getOrDefault("2","0")当map没有key为2的值，会默认返回0而不是为空。

## DTO作为Map的事key时，需要主要什么？

DTO作为一个数据载体，可以看做拥有很多属性的Java类，我就对这些get和set操作，

如果是HashMap的话，一定覆盖equals和HashCode方法，因为get和put的时候，需要进行equals方法进行相等的判断，如果是TreeMap需要实现Comparable。

