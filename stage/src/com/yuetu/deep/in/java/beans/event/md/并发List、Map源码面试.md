# 并发List源码面试

## CopyOnWriteArrayList相关

1. ### 和ArrayList相比有那些相同点和不同点

   答：相同点: 底层数据的数据结构是相同的，都是数组结构，提供了大量了API对数组结构的操作。

     	不同点:CopyOnWriteArrayList是线程安全的，在多线程下使用， 无需加锁。

2. ### CopyOnWriteArrayList通过哪些手段实现线程安全的

   答: 

   1. 数组被volatile修改，保证了数组内存地址被任意修改后，都会通知其他线程

   2. 对数组的所有修改操作，都进行加锁，保证同一时刻，只能一个线程对数组进行修改，比如我在add时，就无法remove

   3. 修改过程中对原数组进行复制，在新的数组上进行修改，在修改过程中，不会对原数组产生影响

      

3. ### 在add方法中，对数组进行加锁后，不是已经线程安全了么，为什么还要进行数组拷贝

    的确，在数组操作进行加锁后，能保障同一时刻，只有一个线程对数组进行add，在同单核下的多线程肯定没有问题，但是多核下，如果我们不进行数组拷贝的话，修改原数组容器的内存地址话，就无法触发volatile可见性效果，那么其他CPU下就无法感知原数组已经被修改，就会引发多核CPU下的线程安全问题

   假设我们不复制拷贝，而在原数组上直接修改，数组的内存地址不变，而数组被volatile修饰时，必须当数组内存地址改变才能通知其他线程，内存地址不变，仅仅是数组元素发生变化时，就无法触发其他线程感应。

4. ### 对老数组进行拷贝，会性能消耗，我们需要注意什么？

   在批量操作时，尽量用addAll、removeAll方法，而不要在循环里面使用add、remove方法，因为for循环里面使用add remove的方式，在每次操作时，都会进行至少一次数组的拷贝，非常消耗性能，而addAll removeAll方法底层做了优化，整体只会进行一次数组拷贝，由此可见，当数据越多的方法就越明显。

5. ###   为什么CopyOnWirteArrayList迭代过程中，数组改动，不会抛出ConcurrentModificationException

   主要因为CopyOnWriteArrayList每次操作时，都会产生新的数组，而迭代时，持有仍然是老的数组，所以数组结构改动时，是用新数组替换老数组，老数组结构并没有发生改变。所以不会抛出错。

6. ### 插入数据正在List中间，请问两种List分别拷贝数组几次，为什么？

   ArrayList只需拷贝一次，假设插入的位置是2，只需要2（包含2） 后面的数据都往后移动一位即可，所以拷贝一次

   CopyOnWriteArrayList拷贝2次，因为CopyOnWriteArrayList多会把老数组的数据拷贝到新数组上，再把2后面的数据往后移一位。







​		

## 